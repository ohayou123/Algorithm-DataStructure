# 目录
[toc]

## 说明
编程语言自身就提供的字符串查找函数，比如Java中的indexOf()，Python中的find()函数等，它们底层就是依赖字符串匹配算法。

>主串和模式串：比方说，我们在字符串A中查找字符串B，那字符串A就是主串，字符串B就是模式串。我们把主串的长度记作n，模式串的长度记作m。因为我们是在主串中查找模式串，所以n>m。

一、单模式串匹配：
1. BF： 简单场景，主串和模式串都不太长, O(m*n)
2. KP：字符集范围不要太大且模式串不要太长， 否则hash值可能冲突，O(n)


## BF算法
BF算法中的BF是Brute Force的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。从名字可以看出，这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高。

在极端情况下，比如主串是“aaaaa…aaaaaa”（省略号表示有很多重复的字符a），模式串是“aaaaab”。我们每次都比对m个字符，要比对n-m+1次，++所以，这种算法的最坏情况时间复杂度是O(n*m)。++++++++++

BF算法的思想可以用一句话来概括，那就是，我们在主串中，检查起始位置分别是0、1、2…n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配的。
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190517200136.png)



虽然暴力，**但是BF算法很常用**：
- 第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把m个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是O(n*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。

- 第二，朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有bug也容易暴露和修复。++在工程中，在满足性能要求的前提下，简单是首选++。这也是我们常说的KISS（Keep it Simple and Stupid）设计原则。



```
public static boolean BF(String main, String mode) {
    char[] arr1 = main.toCharArray();//主串
    char[] arr2 = mode.toCharArray(); //模式串
    int i = mode.length();
    int j = 0;
    while(i < arr1.length && j < arr2.length) { //主串移动指针产生子串和模式串一一对比
        if(arr1[i] == arr2[j]) {
            i++;
            j++;
        }
        else {
            i = i - j + 1;//主串移动一位
            j = 0;
        }
    }
    if(j == arr2.length) return true;
    else return false;
}
```



## RK算法
RK算法的全称叫Rabin-Karp算法。RK算法是BF算法的改进，它巧妙借助了++哈希算法，让匹配的效率有了很大的提升。++

>如果模式串长度为m，主串长度为n，那在主串中，就会有n-m+1个长度为m的子串，我们只需要暴力地对比这n-m+1个子串与模式串，就可以找出主串与模式串匹配的子串。但是，每次检查主串与子串是否匹配，需要依次比对每个字符，所以BF算法的时间复杂度就比较高，是O(n*m)。我们对朴素的字符串匹配算法稍加改造，引入哈希算法，时间复杂度立刻就会降低。

RK算法的思路是这样的：我们通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面我们会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190517200627.png)

通过哈希算法计算子串的哈希值的时候，我们需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高。++这就需要哈希算法设计的非常有技巧了。我们假设要匹配的字符串的字符集中只包含K个字符，我们可以用一个K进制数来表示一个子串，这个K进制数转化成十进制数，作为子串的哈希值++。

>比如要处理的字符串只包含a～z这26个小写字母，那我们就用二十六进制来表示一个字符串。我们把a～z这26个字符映射到0～25这26个数字，a就表示0，b就表示1，以此类推，z表示25。在十进制的表示法中，一个数字的值是通过下面的方式计算出来的。对应到二十六进制，一个包含a到z这26个字符的字符串，计算哈希的时候，我们只需要把进位从10改成26就可以。![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190517200743.png)

这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系。相邻两个子串s[i-1]和s[i]（i表示子串在主串中的起始位置，子串的长度都为m），对应的哈希值计算公式有交集，也就是说，我们可以使用s[i-1]的哈希值很快的计算出s[i]的哈希值
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190517200913.png)![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190517200957.png)
不过，这里有一个小细节需要注意，那就是26^(m-1)这部分的计算，我们可以通过查表的方法来提高效率。我们事先计算好26^0、26^1、26^2……26^(m-1)，并且存储在一个长度为m的数组中，公式中的“次方”就对应数组的下标。当我们需要计算26的x次方的时候，就可以从数组的下标为x的位置取值，直接使用，省去了计算的时间。
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190517201128.png)


### 复杂度
整个RK算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。第一部分，我们前面也分析了，可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是O(n)。

模式串哈希值与每个子串哈希值之间的比较的时间复杂度是O(1)，总共需要比较n-m+1个子串的哈希值，所以，这部分的时间复杂度也是O(n)。所以，RK算法整体的时间复杂度就是O(n)。

### 哈希冲突
之前我们只需要比较一下模式串和子串的哈希值，如果两个值相等，那这个子串就一定可以匹配模式串。但是，当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。

实际上，解决方法很简单。++当我们发现一个子串的哈希值跟模式串的哈希值相等的时候，我们只需要再对比一下子串和模式串本身就好了++。当然，如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身了。

>所以，哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致RK算法的时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成O(n*m)。但也不要太悲观，一般情况下，冲突不会很多，RK算法的效率还是比BF算法高的。

## 解答

![image](https://note.youdao.com/yws/res/34807/AA77DE1584EB4390B43196DCFAA20D6A)假设有下面这样一个二维字符串矩阵（图中的主串），如何在其中查找另一个二维字符串矩阵（图中的模式串）呢？

1. 算出模式串ca的哈希值，我们用（0-26）替换（a-z），那么 ca = 26*2+0 = 52

2. 主串分别取行其计算哈希值（计算的时候根据规律快速从大到小计算），与1中对比。

3. 2中成功，直接取对应行下的两个字母与ef的哈希进行对比，成功则用字母再进行对比。失败则回到2继续比较。
