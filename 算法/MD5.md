

## 概念
 MD5是一个安全的散列算法，输入两个不同的明文不会得到相同的输出值，根据输出值，不能得到原始的明文，==即其过程不可逆==；这样一种被广泛使用的密码杂凑函数，可以产生出一个128位元（16位元组）的散列值（hash value），用于确保信息传输完整一致。
 
- 输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）； 
- 不同的输入得到的不同的结果（唯一性）；

## 生成与验证
摘要哈希生成的正确姿势是什么样呢？分三步：

1. 收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。
2. 按照规则，把参数名和参数值拼接成一个字符串，同时把给定的密钥也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。
3. 利用MD5算法，从原文生成哈希值。MD5生成的哈希值是128位的二进制数，也就是32位的十六进制数。

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190704200447.png)

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190704200507.png)

第三方支付平台如何验证请求的签名？同样分三步：
1. 发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。
2. 第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。
3. 用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做验签。

## MD5生成

简单概括起来，MD5算法的过程分为四步：==处理原文，设置初始值，循环加工，拼接结果==。


>第一步:处理原文

首先，我们计算出原文长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448。填充的方法是第一位填充1，其余位填充0。填充完后，信息的长度就是512*N+448。

之后，用剩余的位置（512-448=64位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是512*(N+1)。

>第二步:设置初始值

MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。MD5的官方实现中，A、B、C、D的初始值如下（16进制）：


```
A=0x01234567
B=0x89ABCDEF
C=0xFEDCBA98
D=0x76543210
```
>第三步:循环加工

这一步是最复杂的一步，我们看看下面这张图，此图代表了单次A,B,C,D值演变的流程。 

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190704200716.png)

图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。

- 假设处理后的原文长度是M 
- 主循环次数 = M / 512 
- 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。

上面这张图所表达的就是单次子循环的流程。

下面对图中其他元素一一解释：

1.绿色F 
图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种：

```
F(X, Y, Z) =(X&Y) | ((~X) & Z)
G(X, Y, Z) =(X&Z) | (Y & (~Z))
H(X, Y, Z) =X^Y^Z
I(X, Y, Z)=Y^(X|(~Z))
```
在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。

2.红色“田”字 

很简单，红色的田字代表相加的意思。

3.Mi 

Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。

4.Ki 

一个常量，在64次子循环中，每一次用到的常量都是不同的。

5.黄色的<<


```
第一轮：
    FF(a,b,c,d,M0,7,0xd76aa478）     s[0]=7,   K[0] = 0xd76aa478
　　FF(a,b,c,d,M1,12,0xe8c7b756）   s[1]=12,  K[1] = 0xe8c7b756
　　FF(a,b,c,d,M2,17,0x242070db)
　　FF(a,b,c,d,M3,22,0xc1bdceee)
　　FF(a,b,c,d,M4,7,0xf57c0faf)
　　FF(a,b,c,d,M5,12,0x4787c62a)
　　FF(a,b,c,d,M6,17,0xa8304613）
　　FF(a,b,c,d,M7,22,0xfd469501）
　　FF(a,b,c,d,M8,7,0x698098d8）
　　FF(a,b,c,d,M9,12,0x8b44f7af)
　　FF(a,b,c,d,M10,17,0xffff5bb1）
　　FF(a,b,c,d,M11,22,0x895cd7be)
　　FF(a,b,c,d,M12,7,0x6b901122）
　　FF(a,b,c,d,M13,12,0xfd987193）
　　FF(a,b,c,d,M14,17, 0xa679438e)
　　FF(a,b,c,d,M15,22,0x49b40821）
第二轮：
　　GG(a,b,c,d,M1,5,0xf61e2562）
　　GG(a,b,c,d,M6,9,0xc040b340）
　　GG(a,b,c,d,M11,14,0x265e5a51）
　　GG(a,b,c,d,M0,20,0xe9b6c7aa)
　　GG(a,b,c,d,M5,5,0xd62f105d)
　　GG(a,b,c,d,M10,9,0x02441453）
　　GG(a,b,c,d,M15,14,0xd8a1e681）
　　GG(a,b,c,d,M4,20,0xe7d3fbc8）
　　GG(a,b,c,d,M9,5,0x21e1cde6）
　　GG(a,b,c,d,M14,9,0xc33707d6）
　　GG(a,b,c,d,M3,14,0xf4d50d87）
　　GG(a,b,c,d,M8,20,0x455a14ed)
　　GG(a,b,c,d,M13,5,0xa9e3e905）
　　GG(a,b,c,d,M2,9,0xfcefa3f8）
　　GG(a,b,c,d,M7,14,0x676f02d9）
　　GG(a,b,c,d,M12,20,0x8d2a4c8a)
第三轮：
　　HH(a,b,c,d,M5,4,0xfffa3942）
　　HH(a,b,c,d,M8,11,0x8771f681）
　　HH(a,b,c,d,M11,16,0x6d9d6122）
　　HH(a,b,c,d,M14,23,0xfde5380c)
　　HH(a,b,c,d,M1,4,0xa4beea44）
　　HH(a,b,c,d,M4,11,0x4bdecfa9）
　　HH(a,b,c,d,M7,16,0xf6bb4b60）
　　HH(a,b,c,d,M10,23,0xbebfbc70）
　　HH(a,b,c,d,M13,4,0x289b7ec6）
　　HH(a,b,c,d,M0,11,0xeaa127fa)
　　HH(a,b,c,d,M3,16,0xd4ef3085）
　　HH(a,b,c,d,M6,23,0x04881d05）
　　HH(a,b,c,d,M9,4,0xd9d4d039）
　　HH(a,b,c,d,M12,11,0xe6db99e5）
　　HH(a,b,c,d,M15,16,0x1fa27cf8）
　　HH(a,b,c,d,M2,23,0xc4ac5665）
第四轮：
　　Ⅱ（a,b,c,d,M0,6,0xf4292244）
　　Ⅱ（a,b,c,d,M7,10,0x432aff97）
　　Ⅱ（a,b,c,d,M14,15,0xab9423a7）
　　Ⅱ（a,b,c,d,M5,21,0xfc93a039）
　　Ⅱ（a,b,c,d,M12,6,0x655b59c3）
　　Ⅱ（a,b,c,d,M3,10,0x8f0ccc92）
　　Ⅱ（a,b,c,d,M10,15,0xffeff47d)
　　Ⅱ（a,b,c,d,M1,21,0x85845dd1）
　　Ⅱ（a,b,c,d,M8,6,0x6fa87e4f)
　　Ⅱ（a,b,c,d,M15,10,0xfe2ce6e0)
　　Ⅱ（a,b,c,d,M6,15,0xa3014314）
　　Ⅱ（a,b,c,d,M13,21,0x4e0811a1）
　　Ⅱ（a,b,c,d,M4,6,0xf7537e82）
　　Ⅱ（a,b,c,d,M11,10,0xbd3af235）
　　Ⅱ（a,b,c,d,M2,15,0x2ad7d2bb)
　　Ⅱ（a,b,c,d,M9,21,0xeb86d391）
```
>第四步:拼接结果 
    这一步就很简单了，把循环加工最终产生的A，B，C，D四个值拼接在一起，转换成字符串即可。

## MD5破解
破解并非把摘要还原成原文。破解属于碰撞：找到其他一个也生产相同摘要即可。


```
设MD5的哈希函数是H（X），那么：
H(A) = M
H(B) = M
任意一个B即为破解结果。
B有可能等于A，也可能不等于A。
```
用一个形象的说法，A和B的MD5结果“殊途同归”。

MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值，每当用户登录时，验签过程如下：![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190704201532.png)

如果我们得到了用户ABC的密码哈希值E10ADC3949BA59ABBE56E057F20F883E，并不需要还原出原密码123456，只需要“碰撞”出另一个原文654321（只是举例）即可。登录时，完全可以使用654321作为登陆密码，欺骗过应用系统的验签。

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190704201613.png)

比如：
>对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。


- 暴力枚举：暴力枚举所有原文
- 字典法：用巨大字典存放尽可能多的原文和哈希值，然后查找
- 彩虹表：两个基本函数
    - H（X）：生成信息摘要的哈希函数，比如MD5，比如SHA256。
    - R（X）：从信息摘要转换成另一个字符串的衰减函数（Reduce）。其中R（X）的定义域是H（X）的值域，R（X）的值域是H（X）的定义域。但要注意的是，R（X）并非H（X）的反函数。
    - 通过交替运算H和R若干次，可以形成一个原文和哈希值的链条。假设原文是aaaaaa，哈希值长度32bit，那么哈希链表就是下面的样子：![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190704201854.png)

- ...

>彩虹表例子：
给定信息摘要：920ECF10

如何得到原文呢？只需进行R（X）运算：

R（920ECF10） = kiebgt

查询哈希表可以找到末端kiebgt对应的首端是aaaaaa，因此摘要920ECF10的原文“极有可能”在aaaaaa到kiebgt的这个链条当中。

接下来从aaaaaa开始，重新交替运算R（X）与H（X），看一看摘要值920ECF10是否是其中一次H（X）的结果。从链条看来，答案是肯定的，因此920ECF10的原文就是920ECF10的前置节点sgfnyd。![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190704202030.png)

需要补充的是，如果给定的摘要值经过一次R（X）运算，结果在哈希表中找不到，可以继续交替H（X）R（X）直到第K次为止。

>缺点：R(X)函数的可靠性，函数难免会出现碰撞,比如：

给定信息摘要：FB107E70

经过多次R（X），H（X）运算，得到结果kiebgt

通过哈希表查找末端kiebgt，可以找出首端aaaaaa

但是，FB107E70并不在aaaaaa到kiebgt的哈希链条当中，这就是R（X）的碰撞造成的。![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190704202224.png)

这个问题看似没什么影响，既然找不到就重新生成一组首尾映射即可。但是想象一下，当K值较大的时候，哈希链很长，一旦两条不同的哈希链在某个节点出现碰撞，后面所有的明文和哈希值全都变成了一毛一样的值。

这样造成的后果就是冗余存储。原本两条哈希链可以存储 2K个映射，由于重复，真正存储的映射数量不足2K。

>这时候彩虹表产生了：把原来的R(X)函数改进从R1（X）到Rk(X)一共K个衰减函数，这样发生碰撞只会发生在同一级，大大减少存储重复几率、
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190704202424.png)