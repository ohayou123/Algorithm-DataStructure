## 介绍
插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
## 步骤
1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

![](https://github.com/binbinbin5/myPics/raw/master/imgs/insertionSort.gif?raw=true)

## 复杂度和稳定性
- 数据结构 ---------- 数组

- 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)

- 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)

- 平均时间复杂度 ---- O(n^2)

- 所需辅助空间 ------ O(1)

- 稳定性 ------------ 稳定

>插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。

## 代码

```

public void sortInsert(int[] arr) {
        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
        for (int i = 1; i < arr.length; i++) {

            // 记录要插入的数据
            int tmp = arr[i];

            // 从已经排序的序列最右边的开始比较，找到比其小的数
            int j = i;
            while (j > 0 && tmp < arr[j - 1]) {
                arr[j] = arr[j - 1];//把需要移动的数的位置变成更往后移的值
                j--;
            }

            // 存在比其小的数，将移动的值插入
            if (j != i) {
                arr[j] = tmp;
            }

        }
}    

比如：[1,3,4,5,6,2]
while循环里 ：从[1,3,4,5,6,6]--> 到[1,3,3,4,5,6]
if判断里交换[1,2,3,4,5,6]
```
