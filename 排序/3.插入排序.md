## 介绍
插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
## 步骤
插入排序包含两种操作，一种是元素的比较，一种是元素的移动

1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/charupaixu1.gif)


## 复杂度和稳定性

- 最差时间复杂度： 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)

- 最优时间复杂度： 最好情况为输入序列是升序排列的,此时时间复杂度O(n)

- 平均时间复杂：O(n^2)
- 稳定性：选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
- 空间复杂度：插入排序算法的运行并不需要额外的存储空间，复杂度是O(1)，这是一个原地排序算法

>插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。

## 代码

```

public void sortInsert(int[] arr) {
        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
        for (int i = 1; i < arr.length; i++) {

            // 记录要插入的数据
            int tmp = arr[i];

            // 从已经排序的序列最右边的开始比较，找到比其小的数
            int j = i;
            while (j > 0 && tmp < arr[j - 1]) {
                arr[j] = arr[j - 1];//把需要移动的数的位置变成更往后移的值
                if(temp > arr[j]){
                    break;//那么提前跳出，不再多余比较
                }
                j--;
            }

            // 存在比其小的数，将移动的值插入
            if (j != i) {
                arr[j] = tmp;
            }

        }
}    

比如：[1,3,4,5,6,2]
while循环里 ：从[1,3,4,5,6,6]--> 到[1,3,3,4,5,6]
if判断里交换[1,2,3,4,5,6]
```

## 二分插入排序
二分法插入排序，简称二分排序，是在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left<right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上。

> 当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。


- 最差时间复杂度 ---- O(n^2)

- 最优时间复杂度 ---- O(nlogn)

- 平均时间复杂度 ---- O(n^2)

- 所需辅助空间 ------ O(1)

- 稳定性 ------------ 稳定



```

public static void insertSortWithBinarySearch(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int temp = arr[i];
        int low = 0, high = i - 1;
        int mid = -1;
        while (low <= high) {            
            mid = low + (high - low) / 2;            
            if (arr[mid] > temp) {               
                high = mid - 1;            
            } else { // 元素相同时，也插入在后面的位置                
                low = mid + 1;            
            }        
        }        
        for(int j = i - 1; j >= low; j--) {            
            arr[j + 1] = arr[j];        
        }        
        arr[low] = temp;    
    }
}

```
