

## 排序算法的执行效率
对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：

1. 最好情况、最坏情况、平均情况时间复杂度
2. 时间复杂度的系数、常数 、低阶
3. 比较次数和交换（或移动）次数


## 排序算法的内存消耗
算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是O(1)的排序算法

## 排序算法的稳定性

针对排序算法，我们还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。
>比如我们有一组数据2，9，3，4，8，3，按照大小排序之后就是2，3，3，4，8，9。

这组数据里有两个3。经过某种排序算法排序之后，如果两个3的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。

>为什么加入稳定性

比如：下单的顺序，稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190508194150.png)

## 排序算法比较
1. 插入排序和冒泡排序的时间复杂度相同，都是O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？

>插入排序和冒泡排序都是稳定的，平均时间复杂度为N^2，最好最坏的时间复杂度也是相同的，但是==交换和赋值的频繁度，插入排序占优势==。


2. 归并和快排这两种排序算法适合大规模的数据排序。而且快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？
>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为O(nlogn)的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190508202432.png)

3. O(n)时间复杂度内求无序数组中的第K大元素。比如，4， 2， 5， 12， 3这样一组数据，第3大元素就是4。
>快排（分区）的思想可以借鉴：我们选择数组区间A[0…n-1]的最后一个元素A[n-1]作为pivot，对数组A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。如果p+1=K，那A[p]就是要求解的元素；如果K>p+1, 说明第K大元素出现在A[p+1…n-1]区间，我们再按照上面的思路递归地在A[p+1…n-1]这个区间内查找。同理，如果K<p+1，那我们就在A[0…p-1]区间查找
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190508204247.png)

3. 如何根据年龄给100万用户排序？
>因为年龄范围很小，最多才100多（假设最老120），所以根据年龄给100万用户排序，就类似按照成绩给50万考生排序。我们假设年龄的范围最小1岁，最大不超过120岁。我们可以遍历这100万用户，根据年龄将其划分到这120个桶里，然后依次顺序遍历这120个桶中的元素。这样就得到了按照年龄排序的100万用户数据。

4. 假设我们现在需要对D，a，F，B，c，A，z这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为a，c，z，D，F，B，A，这个如何来实现呢？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法，又该怎么解决呢？

>因为字母虽然为字母，但是它的ASCII可以进行比较。如果分为三个桶（大写、小写、数字），那么时间复杂度应该不会达到O(n)，因为O(nlog(n/m))中的m只有3，时间复杂度会退化到O(nlogn)。如果要达到O(n)的复杂度，我认为应该使用计数排序，将A-Za-z0-9作为62个桶，这样遍历一次就可以完成排序。（如果上述理解有偏差，请作者务必指出，多谢！） 

5. 如何实现一个通用的、高性能的排序函数？
>首先：三个线性排序虽然时间复杂度低了，但是使用场景都比较限制，所以如果要写一个通用的排序函数，不能选择线性排序算法。

>再者：如果对小规模数据进行排序，可以选择时间复杂度是O(n^2)的算法；如果对大规模数据进行排序，时间复杂度是O(nlogn)的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是O(nlogn)的排序算法来实现排序函数。

>然后：归并排序、快速排序、堆排序、希尔四个排序。虽然归并的最好最坏平均时间复杂度都为NlogN,但是不是原地算法，还要外部空间，所以不常用。还有希尔排序不稳定。

>最后选择快排和堆之一：Java语言采用堆排序实现排序函数，C语言使用快速排序实现排序函数。但是对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。而且堆排序比快排访问方式不友好。

对快排进行优化：
- 1.三数取中法
我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。

- 2.随机法
随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选的很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的O(n2)的情况，出现的可能性不大。

```
//快排改进：三数中值法
private static void swap(int[] arr,int i,int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    private static void threeNumber(int[] arr,int left,int right){

        int mid = (left + right) / 2;
        if (arr[left] > arr[mid]) {
            swap(arr, left, mid);
        }
        if (arr[left] > arr[right]) {
            swap(arr, left, right);
        }
        if (arr[right] < arr[mid]) {
            swap(arr, right, mid);
        }
        swap(arr, right - 1, mid);

    } //取前中后三个值比较后交换排序，
    
    
    public static void quickSort(int[] arr,int left,int right){

        //分割
        threeNumber(arr,left,right);
        if(right-left+1>3)//对于长度小于三的情况median函数足以处理
        {
            int pivot = right-1;
            int i=left;
            int j=right-1;
            while(true){
                while(arr[++i]<arr[pivot]){}//从第二位向后询值
                while(arr[--j]>arr[pivot]){}//从中值之前，即倒数第二位向前询值
                if(i<j)
                    swap(arr,i,j);
                else
                    break;
            }
            swap(arr,i,right-1);//当i>j时将其中一个大于中值的值与中值交换位置
            quickSort(arr, left, i-1);
            quickSort(arr, i+1, right);

        }

    }

```
