### 概念
堆是一个树形结构，其实堆的底层是一棵完全二叉树。而完全二叉树是一层一层按照进入的顺序排成的。它没有使用父指针或者子指针。

>作用：
- 构建优先队列
- 支持堆排序
- 快速找出一个集合中的最小值（或者最大值）

>根据两者的差别在于节点的排序方式，分为两种：
- 最大堆：在最大堆中，父节点的值比每一个子节点的值都要大
- 最小堆：在最小堆中，父节点的值比每一个子节点的值都要小

>注意：堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。--唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个。

### 堆的显示：
1. 节点的顺序。在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。
2. 内存占用。普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额为是我内存。堆仅仅使用一个数据来村塾数组，且不使用指针。
3. 平衡。二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。
4. 搜索。在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。
5. 在堆中，在当前层级所有的节点都已经填满之前不允许开是下一层的填充，所以堆总是有这样的形状
![1556444987(1).png](https://i.loli.net/2019/04/28/5cc57751777e2.png)



![1556445070(1).png](https://i.loli.net/2019/04/28/5cc57797f1538.png)


## 堆的实现与位置
> 堆是由数组进行实现的：

![1556444863(1).png](https://i.loli.net/2019/04/28/5cc576d1200b6.png)

> 根据上图可以求叶子节点

所以整个堆中的节点数目为：* 2^(H+1) - 1* （H为高）

> 因为没有指针，所以父子节点的确定通过公式规律：

- 当前节点的父节点 = index / 2
- 当前节点的左子节点 = index * 2
- 当前节点的左子节点 = index * 2 + 1

> 因为堆是由数组构成的，所以索引从0 开始，所以节点的位置也变成：

- 当前节点的父节点 = (index - 1) / 2
- 当前节点的左子节点 = index * 2 + 1
- 当前节点的左子节点 = index * 2 + 2

## 操作
- 上浮 shift_up；
- 下沉 shift_down
- 插入 insert
- 删除 detele
- 堆排序 heap_sort

### Shift Up
如何添加元素：我们需要做的是，将新加入元素调整到合适位置，使得整个二叉树依然保持最大堆的性质。 首先我们需要比较新加入元素和父节点比，如果满足条件则交换位置，直到完成。


### Shift Down
思想：首先优先队列取出数据应该是根节点元素，这样就少了一个元素，之后我们去最后一个节点放到根节点上，然后把父节点和左右子节点进行比较（替换规则是和两个子元素中最小/大的一个替换），满足条件则交换对象，直达最后



### 插入
我们通过一个插入例子来看看插入操作的细节。我们将数字 16 插入到这个堆中：


```
堆的数组是： [ 10, 7, 2, 5, 1 ]
```

第一股是将新的元素插入到数组的尾部。数组变成：
根据堆的规则，插入元素与父类比较，如果比他大/小就交换位置

```
[ 16, 7,10, 5, 1 ,2]
```

>那么步骤如下图

![1556445431(1).png](https://i.loli.net/2019/04/28/5cc57928b9ad7.png)
![1556445435(1).png](https://i.loli.net/2019/04/28/5cc579340a586.png)
![1556445439(1).png](https://i.loli.net/2019/04/28/5cc57934089b8.png)
![1556445442(1).png](https://i.loli.net/2019/04/28/5cc5793427961.png)

在插入操作中，交换次数最大即为树的高度（log n）
### 删除根节点为例子
因为根节点没有了,先我们需要根节点，所以我们需要把新的树头与子元素比较替换，然后再根据规则下浮交换：

![1556445571(1).jpg](https://i.loli.net/2019/04/28/5cc579b0d98ea.jpg)
![1556445574(1).png](https://i.loli.net/2019/04/28/5cc579b0de720.png)
![1556445581(1).png](https://i.loli.net/2019/04/28/5cc579b0dcd50.png)
![1556445584.png](https://i.loli.net/2019/04/28/5cc579b0dfad4.png)
![1556445588(1).png](https://i.loli.net/2019/04/28/5cc579b0db3b9.png)



### 堆的排序

1.  堆顶元素R[1]与最后一个元素R[n]交换，交换后堆长度减一
2.  重新调整堆。此时又不满堆的性质，则需调整继续调整(从顶点开始往下调整)
3.  重复1，2，1，2..直到元素为0


## 代码

```
 //向最大堆中插入元素, heap:存放堆元素的数组
    public static void insert(ArrayList<Integer> array, int value) {
        //在数组的尾部添加
        if(array.size()==0)
            array.add(value);//数组下标为0的位置不放元素

        shift_up(array, array.size() - 1);

    }

    //上升，让插入的数和父节点的数值比较，当大于父节点的时候就和父节点的值相交换
    public static void shift_up(ArrayList<Integer> array, int index) {

        //注意由于数值是从下标为0开始，当index = 0的时候，已经是根节点了
        if (index > 0) {
            //求出父亲的节点
            int parent =   (index - 1) / 2;

            //获取相应位置(头尾)的数值
            int parentValue = array.get(parent);
            int indexValue =  array.get(index);
            //如果父亲节点比index的数值小，就交换二者的数值
            if (parentValue < indexValue) {
                //交换数值
                swap(array, parent, index);
                //递归调用
                shift_up(array, parent);
            }

        }
    }
    public static void delete(ArrayList<Integer> array,int index) {
        //把最后的一个叶子的数值赋值给index位置

        array.set(index,array.get(array.size()-1)) ;
        array.remove(array.size()-1);
        //下沉操作
        shift_down(array, index);
        //把最后一个位置的数字删除

    }

    public static void shift_down(ArrayList<Integer> array, int index) {
        int len = array.size() - 1;

        //记录最大的那个儿子节点的位置
        int child = -1;

        //2*index>n说明该节点没有左右儿子节点了，那么就返回
        if (index * 2 + 1> len) {
            return;
        } else if (2 * index + 1 < len) {//如果左右儿子都存在

            //定义左儿子节点
            child = 2 * index +1;
            //如果左儿子小于右儿子的数值，取右儿子的下标
            if ((Integer) array.get(child) < (Integer) array.get(child + 1)) {
                child++;
            }

        } else if (2 * index == len) {//如果只有一个儿子（左儿子节点）
            child = 2 * index + 1;
        }

        if (array.get(child) >  array.get(index)) {
            //交换堆中的child，和index位置的值
            swap(array, child, index);

            //完成交换后递归调用，继续下降
            shift_down(array, child);
        }
    }
```

```
//堆排序
 public static void heapSort(int[] array) {
        if (array == null || array.length == 1)
            return;

        buildMaxHeap(array); // 第一次排序，构建最大堆，只保证了堆顶元素是数组里最大的

        for (int i = array.length - 1; i >= 1; i--) {
           // 每次把最大（最小）的根节点拿走，再和末尾元素交换，再排序
           // 每次数组大小减1
            swap(array, 0, i);
            //maxHeap(array, i, 0);
            minHeap(array, i, 0);
        }
    }

    // 构建堆
    public static void buildMaxHeap(int[] array) {
        if (array == null || array.length == 1)
            return;

        //  int root = 2*i, int left = 2*i+1, int right = 2*i+2;
        int len = array.length / 2; //从非叶子节点，从下到上
        for (int i = len; i >= 0; i--) {
           //maxHeap(array, array.length, i);
            minHeap(array, array.length, i);
        }
    }

    // 最大堆
    public static void maxHeap(int[] array, int heapSieze, int index) {
        int left = index * 2 + 1; // 左子节点
        int right = index * 2 + 2; // 右子节点
        int maxValue = index; // 暂时定在Index的位置就是最大值

         // 左节点和根节点比较
        if (left < heapSieze && array[left] > array[maxValue]) {
            maxValue = left;
        }

        // 右节点和根节点比较
        if (right < heapSieze && array[right] > array[maxValue]) {
            maxValue = right;
        }

         // 取孩子节点最大值与根节点比较交换
        if (maxValue != index) {
            swap(array, index, maxValue); // 就要交换位置元素

            // 测试
            maxHeap(array, heapSieze, maxValue);
        }
    }

    // 最小堆
    public static void minHeap(int[] array, int heapSieze, int index) {
        int left = index * 2 + 1; 
        int right = index * 2 + 2; 
        int maxValue = index; 

     
        if (left < heapSieze && array[left] < array[maxValue]) {
            maxValue = left;
        }

 
        if (right < heapSieze && array[right] < array[maxValue]) {
            maxValue = right;
        }

     
        if (maxValue != index) {
            swap(array, index, maxValue); 
            minHeap(array, heapSieze, maxValue);
        }
    }

    // 数组元素交换
    public static void swap(int[] array, int index1, int index2) {
        int temp = array[index1];
        array[index1] = array[index2];
        array[index2] = temp;
    }
```
