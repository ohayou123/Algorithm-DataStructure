### 概念
堆是一个树形结构，其实堆的底层是一棵完全二叉树。而完全二叉树是一层一层按照进入的顺序排成的。它没有使用父指针或者子指针。

>作用：
- 构建优先队列
- 支持堆排序
- 快速找出一个集合中的最小值（或者最大值）

>根据两者的差别在于节点的排序方式，分为两种：
- 最大堆：在最大堆中，父节点的值比每一个子节点的值都要大
- 最小堆：在最小堆中，父节点的值比每一个子节点的值都要小

>注意：堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。--唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个。

### 堆的显示：
1. 节点的顺序。在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。
2. 内存占用。普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额为是我内存。堆仅仅使用一个数据来村塾数组，且不使用指针。
3. 平衡。二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。
4. 搜索。在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。
5. 在堆中，在当前层级所有的节点都已经填满之前不允许开是下一层的填充，所以堆总是有这样的形状
![1556444987(1).png](https://i.loli.net/2019/04/28/5cc57751777e2.png)



![1556445070(1).png](https://i.loli.net/2019/04/28/5cc57797f1538.png)


## 堆的实现与位置
> 堆是由数组进行实现的：

![1556444863(1).png](https://i.loli.net/2019/04/28/5cc576d1200b6.png)

> 根据上图可以求叶子节点

所以整个堆中的节点数目为：* 2^(H+1) - 1* （H为高）

> 因为没有指针，所以父子节点的确定通过公式规律：

- 当前节点的父节点 = index / 2
- 当前节点的左子节点 = index * 2
- 当前节点的左子节点 = index * 2 + 1

> 因为堆是由数组构成的，所以索引从0 开始，所以节点的位置也变成：

- 当前节点的父节点 = (index - 1) / 2
- 当前节点的左子节点 = index * 2 + 1
- 当前节点的左子节点 = index * 2 + 2

## 操作
- 上浮 shift_up；
- 下沉 shift_down
- 插入 push
- 弹出 pop
- 取顶 top
- 堆排序 heap_sort

### Shift Up
如何添加元素：我们需要做的是，将新加入元素调整到合适位置，使得整个二叉树依然保持最大堆的性质。 首先我们需要比较新加入元素和父节点比，如果满足条件则交换位置，直到完成。


### Shift Down
思想：首先优先队列取出数据应该是根节点元素，这样就少了一个元素，之后我们去最后一个节点放到根节点上，然后把父节点和左右子节点进行比较（替换规则是和两个子元素中最小/大的一个替换），满足条件则交换对象，直达最后



### 插入
我们通过一个插入例子来看看插入操作的细节。我们将数字 16 插入到这个堆中：


```
堆的数组是： [ 10, 7, 2, 5, 1 ]
```

第一股是将新的元素插入到数组的尾部。数组变成：
根据堆的规则，插入元素与父类比较，如果比他大/小就交换位置

```
[ 16, 7,10, 5, 1 ,2]
```

>那么步骤如下图

![1556445431(1).png](https://i.loli.net/2019/04/28/5cc57928b9ad7.png)
![1556445435(1).png](https://i.loli.net/2019/04/28/5cc579340a586.png)
![1556445439(1).png](https://i.loli.net/2019/04/28/5cc57934089b8.png)
![1556445442(1).png](https://i.loli.net/2019/04/28/5cc5793427961.png)

在插入操作中，交换次数最大即为树的高度（log n）
### 删除根节点
因为根节点没有了,先我们需要根节点，所以我们需要把新的树头与子元素比较替换，然后再根据规则下浮交换：

![1556445571(1).jpg](https://i.loli.net/2019/04/28/5cc579b0d98ea.jpg)
![1556445574(1).png](https://i.loli.net/2019/04/28/5cc579b0de720.png)
![1556445581(1).png](https://i.loli.net/2019/04/28/5cc579b0dcd50.png)
![1556445584.png](https://i.loli.net/2019/04/28/5cc579b0dfad4.png)
![1556445588(1).png](https://i.loli.net/2019/04/28/5cc579b0db3b9.png)



### 堆的排序

1.  堆顶元素R[1]与最后一个元素R[n]交换，交换后堆长度减一
2.  重新调整堆。此时又不满堆的性质，则需调整继续调整(从顶点开始往下调整)
3.  重复1，2，1，2..直到元素为0


## 代码

```

```

