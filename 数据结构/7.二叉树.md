# 目录
[toc]

## 介绍
树是一种非线性的数据结构，是由n（n >=0）个结点组成的有限集合。
如果n==0，树为空树。
如果n>0，
树有一个特定的结点，根结点
根结点只有直接后继，没有直接前驱。
除根结点以外的其他结点划分为m（m>=0）个互不相交的有限集合，T0，T1，T2，...，Tm-1，每个结合是一棵树，称为根结点的子树。


![image](http://note.youdao.com/yws/res/32939/F11177D5AEFB4197A25E10825914CB8C)
>关于树，有几个比较常用的概念你需要掌握，那就是：根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度、层数，以及树的高度。

- 树种每个元素我们叫作“节点”；用来连线相邻节点之间的关系，我们叫作“父子关系”，没有子节点的叫做叶子节点，没有父节点的叫根节点。

- 关于“树”，还有三个比较相似的概念：高度（Height）、深度（Depth）、层（Level）。
![image](http://note.youdao.com/yws/res/32949/E36A4D5D8F69403589EA7F56B1BCDA62)

>例子
![image](http://note.youdao.com/yws/res/32943/9CE445670B6C406181D85D937ECB14E8)
A节点就是B节点的父节点，B节点是A节点的子节点。B、C、D这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫作根节点，也就是图中的节点E。我们把没有子节点的节点叫作叶子节点或者叶节点，比如图中的G、H、I、J、K、L都是叶子节点。

>![image](http://note.youdao.com/yws/res/32951/5AC1FD297FDC48EAAF2AD623948DA520)

## 二叉树（Binary Tree）
二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。
### 满二叉树和完全二叉树
![image](http://note.youdao.com/yws/res/32956/BF49812A017B4F2EB2EEFF400F89C872)
- 编号2的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作 ++满二叉树++。
- 编号3的二叉树中，**叶子节点都在最底下两层，*最后一层的叶子节点都靠左排列***，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作 ++完全二叉树++。
![image](http://note.youdao.com/yws/res/32964/38E5FE6C24554A0C8220F4A215C0FEDE)

## 如何表示（或者存储）一棵二叉树？
>想要存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。

1. 简单、直观的链式存储法。从图中你应该可以很清楚地看到，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。
![image](http://note.youdao.com/yws/res/32969/C98E949BFAC949F9A561E76DA1C6422E)

2. 基于数组的顺序存储法。我们把根节点存储在下标i = 1的位置，那左子节点存储在下标2 * i = 2的位置，右子节点存储在2 * i + 1 = 3的位置。以此类推，B节点的左子节点存储在2 * i = 2 * 2 = 4的位置，右子节点存储在2 * i + 1 = 2 * 2 + 1 = 5的位置。
![image](http://note.youdao.com/yws/res/32974/5D59B24F0FE0417D98507576D17E8903)
注意：==如果节点X存储在数组中下标为i的位置，下标为2 * i 的位置存储的就是左子节点，下标为2 * i + 1的位置存储的就是右子节点==。反过来，下标为i/2的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为1的位置），这样就可以通过下标计算，把整棵树都串起来。

>如果是非完全二叉树，其实会浪费比较多的数组存储空间。所以如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。![image](http://note.youdao.com/yws/res/32982/68AE71167B8740F2A35DD05D05537E6C)

## 二叉树的操作
### 遍历
>经典的方法有三种+一种，前序遍历、中序遍历和后序遍历。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。还有一种是层序遍历，按照层来。

- 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。（根左右）

- 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。（左根右）

- 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。（左右根）

- 层序遍历是指，对于树来讲，按照1，2，3..层的顺序，从上到下，从左右到的顺序遍历。
- 
- 二叉树遍历的时间复杂度是O(n)。

![image](http://note.youdao.com/yws/res/32990/2E249C6AB4BA4323A0B72F55CE41BBEE)
>通过前序中序或者中序后续可以确定一棵树。


```
前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r

//节点
public static class Node { //节点
    private int data;
    private Node left;
    private Node right;

    public Node(int data) {
      this.data = data;
    }
  }
```

```
//前序遍历递归的方式
    public void preOrder(BinaryTreeNode root){
        if(null!=root){
            System.out.print(root.getData()+"\t");
            preOrder(root.getLeft());
            preOrder(root.getRight());
        }
    }
    
    //前序遍历非递归的方式
    public void preOrderNonRecursive(BinaryTreeNode root){
        Stack<BinaryTreeNode> stack=new Stack<BinaryTreeNode>();
        while(true){
            while(root!=null){
                System.out.print(root.getData()+"\t");
                stack.push(root);
                root=root.getLeft();
            }
            if(stack.isEmpty()) break;
            root=stack.pop();
            root=root.getRight();
        }
    }
```


```
//中序遍历采用递归的方式
    public void inOrder(BinaryTreeNode root){
        if(null!=root){
            inOrder(root.getLeft());
            System.out.print(root.getData()+"\t");
            inOrder(root.getRight());
        }
    }
    
    //中序遍历采用非递归的方式
    public void inOrderNonRecursive(BinaryTreeNode root){
        Stack<BinaryTreeNode> stack=new Stack<BinaryTreeNode>();
        while(true){
            while(root!=null){
                stack.push(root);
                root=root.getLeft();
            }
            if(stack.isEmpty())break;
            root=stack.pop();
            System.out.print(root.getData()+"\t");
            root=root.getRight();
        }
    }
```



```
//后序遍历采用递归的方式
public void postOrder(BinaryTreeNode root){
    if(root!=null){
        postOrder(root.getLeft());
        postOrder(root.getRight());
        System.out.print(root.getData()+"\t");
    }
}

//后序遍历采用非递归的方式
public void postOrderNonRecursive(BinaryTreeNode root){
    Stack<BinaryTreeNode> stack=new Stack<BinaryTreeNode>();
    while(true){
        if(root!=null){
            stack.push(root);
            root=root.getLeft();
        }else{
            if(stack.isEmpty()) return;
            
            if(null==stack.lastElement().getRight()){
                root=stack.pop();
                System.out.print(root.getData()+"\t");
                while(root==stack.lastElement().getRight()){
                    System.out.print(stack.lastElement().getData()+"\t");
                    root=stack.pop();
                    if(stack.isEmpty()){
                        break;
                    }
                }
            }
            
            if(!stack.isEmpty())
                root=stack.lastElement().getRight();
            else
                root=null;
        }
    }
}

```

```
//层序遍历
1.对于不为空的结点，先把该结点加入到队列中
2.从队中拿出结点，如果该结点的左右结点不为空，就分别把左右结点加入到队列中
3.重复以上操作直到队列为空

public void levelOrder(BinaryTreeNode root){
    BinaryTreeNode temp;
    Queue<BinaryTreeNode> queue=new LinkedList<BinaryTreeNode>();
    queue.offer(root);
    while(!queue.isEmpty()){
        temp=queue.poll();
        System.out.print(temp.getData()+"\t");
        if(null!=temp.getLeft()) 
            queue.offer(temp.getLeft());
        if(null!=temp.getRight()){
            queue.offer(temp.getRight());
        }
    }
}
    
```




## 查找二叉树
二叉查找树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。
>二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：
1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2. 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
3. 左、右子树也分别为二叉排序树；
4. 没有键值相等的节点。

![image](http://note.youdao.com/yws/res/33070/4F20A0EA7A0644309D98419BDD37C94A)
>二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。

>二叉查找树的时间复杂度：
- 它和二分查找一样，插入和查找的时间复杂度均为O(logn)，
- 但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。

>二叉查找树的高度决定了二叉查找树的查找效率
### 节点

```
public static class Node { //节点
    private int data;
    private Node left;
    private Node right;

    public Node(int data) {
      this.data = data;
    }
  }
```


### 查找
我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。
![image](http://note.youdao.com/yws/res/33075/342EAC8C399740CFA322F86D2F148546)

```
public class BinarySearchTree {
  private Node tree;

  public Node find(Node tree,int data) {
    Node p = tree;
    while (p != null) { //迭代
      if (data < p.data) p = p.left;//小于往左子树差
      else if (data > p.data) p = p.right;//大于往右子树查
      else return p;//等于抛出自身
    }
    return null;//没有抛出Null
  }

}
```



### 插入
1. 若当前的二叉查找树为空，则插入的元素为根节点;
2. 若插入的元素值小于根节点值，则将元素插入到左子树中;
3. 若插入的元素值不小于根节点值，则将元素插入到右子树中。

![image](http://note.youdao.com/yws/res/33083/29B906556C6B4E048A80D49E9BA88688)
```
public void insert(Node tree,int data) {
  if (tree == null) {//空为根节点
    tree = new Node(data);
    return;
  }

  Node p = tree;
  while (p != null) {//不为空
    if (data > p.data) { //大于插入左子树
      if (p.right == null) {
        p.right = new Node(data);
        return;
      }
      p = p.right;
    } else { //小于插入右子树
      if (p.left == null) {
        p.left = new Node(data);
        return;
      }
      p = p.left;
    }
  }
}

```

### 删除
分三种情况进行处理：
1. 第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为null。比如图中的删除节点55。

2. 第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点13。

3. 第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点18

![image](http://note.youdao.com/yws/res/33088/197838E7EBD24D5E96ACFBB4DBE5163F)
```
public void delete(Node tree,int data) {
  Node p = tree; // p指向要删除的节点，初始化指向根节点
  Node pp = null; // pp记录的是p的父节点
  
  while (p != null && p.data != data) {//找到要删除的节点
    pp = p;
    if (data > p.data) p = p.right;
    else p = p.left;
  }
  if (p == null) return; // 没有找到

  // 要删除的节点有两个子节点
  if (p.left != null && p.right != null) { // 查找右子树中最小节点
    Node minP = p.right;
    Node minPP = p; // minPP表示minP的父节点
    while (minP.left != null) {
      minPP = minP;
      minP = minP.left;
    }
    p.data = minP.data; // 将minP的数据替换到p中
    p = minP; // 下面就变成了删除minP了
    pp = minPP;
  }

  // 删除节点是叶子节点或者仅有一个子节点
  Node child; // p的子节点
  if (p.left != null) child = p.left;
  else if (p.right != null) child = p.right;
  else child = null;

  if (pp == null) tree = child; // 删除的是根节点
  else if (pp.left == p) pp.left = child;
  else pp.right = child;
}

```
### 最大最小值


```
public Node findMin(Node tree) {
    if (tree == null) return null;
    Node p = tree;
    while (p.left != null) {//肯定在左节点，只要迭代直到当前节点没有左子树
      p = p.left;
    }
    return p;
  }

  public Node findMax(Node tree) {
    if (tree == null) return null;
    Node p = tree;
    while (p.right != null) {//肯定在右节点，只要迭代直到当前节点没有右子树
      p = p.right;
    }
    return p;
  }
```
### 中序遍历等于排序

```
public static void inOrder(Node tree){//左根右
    Node p = tree;
    if(p!=null){
        inOrder(p.left)
        system.out.println("p.data");
        inOrder(p.right);
    }
}
```


## 解答
1. 给定一组数据N，比如1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？

>有N个数的数组，而且是二叉树，那么可以构建N！种（N取1放根节点，依次从剩下的取）。所以[1,3,5,6,9,10] 6个数有 6*5*4*3*2*1=720种。



2. 前、中、后序。实际上，还有另外一种遍历方式，也就是按层遍历，你知道如何实现吗？
>按层遍历，可以看作以根结点为起，像下遍历。


3. 找到一个二叉树的高度：

>递归查找null节点 ，设置标识几次，

4. 找到一个二叉搜索树中第 k 个最大值：

>中序遍历即可，中序遍历为有序数列。

5. 找到距离根部“k”个距离的节点：
 
```
//递归K次
void printKDistant(Node node, int k) 
{
    if (node == null)
        return;
    if (k == 0) 
    {
        System.out.print(node.data + " ");
        return;
    } 
    else
    {
        printKDistant(node.left, k - 1);
        printKDistant(node.right, k - 1);
    }
}
```



6. 找到一个二叉树中给定节点的祖先（ancestors）：
 
```
//迭代
boolean printAncestors(Node node, int target) 
{
     /* base cases */
    if (node == null)
        return false;

    if (node.data == target)
        return true;

    /* If target is present in either left or right subtree 
       of this node, then print this node */
    if (printAncestors(node.left, target)
            || printAncestors(node.right, target)) 
    {
        System.out.print(node.data + " ");
        return true;
    }
    return false;
}
```
