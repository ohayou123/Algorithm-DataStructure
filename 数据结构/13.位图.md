# 目录

[toc]

## 介绍

1. 长度为10的bitmap，每一格bit对应0-9的10个整型数。

     0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
    ---|---|---|---|---|---|---|---|---|---
     0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

2. 把整型数1，4导入bitmap中，那么对应下标为4的位置，将此bit置为1

     0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0
    ---|---|---|---|---|---|---|---|---|---
     0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

3. 此时bitmap中存储那些数据就很明显，有1和4，而且bitmap还会去重。

3. 比如用位图存储信息，一旦人多了之后，列表更多，存储更大。这时候我们可以使用位图进行存储：

    ID | Sex | Age | Occu | Phone
    ---|---|---|---|---|---|
    1  | 男 | 90后 | 程序员 | iPhone
    2 | 男 | 90后 | 程序员 | HUAWEI
    3  | 女 | 00后 | 学生 | iPhone

    SEX | 位图   
    ---|---
    男  | 1，2
    女  | 3

    Occu | 位图  
    ---|---
    程序员  | 1，2
    学生  | 3

4. 这样实现实现用户的去重和查询统计：

    程序员：
     0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0
    ---|---|---|---|---|---|---|---|---|---
     0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

    00后：
     0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0
    ---|---|---|---|---|---|---|---|---|---
     0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

    iPhone手机：
     0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0
    ---|---|---|---|---|---|---|---|---|---
     0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

- 如果查询程序员用iPhone的：

```
01110000000B & 0100000000B = 0100000000B
//只有1号程序员用iPhone
```
- 如果查询00后或者用iPhone手机的

```
00010000000B | 0101000000B = 0101000000B
//1号和3号符合
```


5. 位图每个只占1bit，就算1亿数据，也就12MB左右的存储空间。


6. 不支持非运算
    但是我们不能说除了1，2都不是程序员，实际上只有3个人，3不是学生而已：
    
    程序员：
     0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0
    ---|---|---|---|---|---|---|---|---|---
     0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

     1 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1
    ---|---|---|---|---|---|---|---|---|---
     0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

    但是我们可以借助全量的位图来进行异或运算

    程序员：
     0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0
    ---|---|---|---|---|---|---|---|---|---
     0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
    所有人员：
     0 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0
    ---|---|---|---|---|---|---|---|---|---
     0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
 
 
```
0110000000B^0111000000B=0001000000B
//只有3号不是程序员
```

 
 
7. 如果为图中1亿个数据，全是2个数的重复，那么造成空间浪费？

    我们可以对位图进行优化：BitMap把bit放入Long数组中，因为Long一个占64位,所以这64位是bit的子集，每个子集称为word。

    刚开始创建的时候，只有4个word，而且第一个word作为头，不存放，而且没插入，都是0。![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521193322.png)

    当插入用户1的时候：![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521193350.png) Word1变成2，是因为00000010B中最右边二进制位0，是0用户，那么从右到左第二位有1，代表用户1存在。

    因为每个最大是64，所以当插入64存在word2中，129的时候存在第三个word中，![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521193423.png)

    当所有word都在占领，那么会动态扩容。![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521193446.png)

    但是如果要插入为40000的用户时候，不会扩容6250个word，而是改变后面两个word,一个设置成特殊word，另一个存放40000用户word（跨度信息存储 RLW）![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521193523.png)

```
25769803776L  =  11000000000000000000000000000000000B

8589947086L = 1000000000000000000011000011001110B

//低32位表示跨越多少空word
//高32位表示当前后方有多少个LW（直接存储不跨度）
```
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521193545.png)


>如果按照上面的思想，word跨度够多。那么新插入数据依靠每个RLW作为路标，比如：40003

1. 解析Word0，得知当前RLW横跨的空Word数量为0，后面有连续3个普通Word。
2. 计算出当前RLW后方连续普通Word的最大ID是  64 X  (0 + 3) -1 = 191。
3. 由于 191 < 400003，所以新ID必然在下一个RLW（Word4）之后。
4. 解析Word4，得知当前RLW横跨的空Word数量为6247，后面有连续1个普通Word。
5. 计算出当前RLW（Word4）后方连续普通Word的最大ID是191 + （6247 + 1）X64  = 400063。
6. 由于400003 < 400063，因此新ID 400003的正确位置就在当前RLW（Word4）的后方普通Word，也就是Word5当中。
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521193718.png)

    如果插入20001，那么RLW跨度进行分开：![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521193639.png)



### 例子：
>我们有1千万个整数，整数的范围在1到1亿之间。如何快速查找某个整数是否在这1千万个整数中呢？

当然，这个问题还是可以用散列表来解决。不过，我们可以使用一种比较“特殊”的散列表，那就是位图。我们申请一个大小为1亿、数据类型为布尔类型（true或者false）的数组。我们将这1千万个整数作为数组下标，将对应的数组值设置成true。比如，整数5对应下标为5的数组值设置为true，也就是array[5]=true。

当我们查询某个整数K是否在这1千万个整数中的时候，我们只需要将对应的数组值array[K]取出来，看是否等于true。如果等于true，那说明1千万整数中包含这个整数K；相反，就表示不包含这个整数K。

>不过，很多语言中提供的布尔类型，大小是1个字节的，并不能节省太多内存空间。实际上，表示true和false两个值，我们只需要用一个二进制位（bit）就可以了。那如何通过编程语言，来表示一个二进制位呢？

这里就要用到位运算了。我们可以借助编程语言中提供的数据类型，比如int、long、char等类型，通过位运算，用其中的某个位表示某个数字。



```
public class BitMap {
  private char[] bytes;
  private int nbits;
  
  public BitMap(int nbits) {
    this.nbits = nbits;
    this.bytes = new char[nbits/8+1];
  }

  public void set(int k) {
    if (k > nbits) return;
    int byteIndex = k / 8;
    int bitIndex = k % 8;
    bytes[byteIndex] |= (1 << bitIndex);
  }

  public boolean get(int k) {
    if (k > nbits) return false;
    int byteIndex = k / 8;
    int bitIndex = k % 8;
    return (bytes[byteIndex] & (1 << bitIndex)) != 0;
  }
}
```
位图通过数组下标来定位数据，所以，访问效率非常高。而且，每个数字用一个二进制位来表示，在数字范围不大的情况下，所需要的内存空间非常节省。


## 布隆过滤器
布隆过滤器非常适合这种不需要100%准确的、允许存在小概率误判的大规模判重场景

我们有个假设，就是数字所在的范围不是很大。如果数字的范围很大，比如刚刚那个问题，数字范围不是1到1亿，而是1到10亿，那位图的大小就是10亿个二进制位，也就是120MB的大小，消耗的内存空间，不降反增。++布隆过滤器就是为了解决这个问题，对位图这种数据结构的一种改进++。

布隆过滤器的做法是，++我们仍然使用一个1亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这1到1亿范围内++。比如我们把哈希函数设计成f(x)=x%n。其中，x表示数字，n表示位图的大小（1亿），也就是，对数字跟位图的大小进行取模求余。

>哈希函数会存在冲突的问题？

既然一个哈希函数可能会存在冲突，那用多个哈希函数一块儿定位一个数据我们使用K个哈希函数，对同一个数字进行求哈希值，那会得到K个不同的哈希值，我们分别记作X_1，X_2，X_3，…，X_K。我们把这K个数字作为位图中的下标，将对应的BitMap[X_1]，BitMap[X_2]，BitMap[X_3]，…，BitMap[X_K]都设置成true，也就是说，我们用K个二进制位，来表示一个数字的存在。

图中163经过3个HASH算法产生三个不同的HASH放入位图中，如果要查询163，那么把他通过三个hash查询，如果对于三个都是1，那么存在。
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521163438.png)



>尽管采用K个哈希函数之后，两个数字哈希冲突的概率降低了，但是，这种处理方式又带来了新的问题，那就是容易误判。![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521163633.png)

布隆过滤器的误判有一个特点，那就是，++它只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那说明这个数字真的不存在，不会发生误判；如果某个数字经过布隆过滤器判断存在，这个时候才会有可能误判，有可能并不存在++。不过，只要我们调整哈希函数的个数、位图大小跟要存储数字的个数之间的比例，那就可以将这种误判的概率降到非常低。

++尽管布隆过滤器会存在误判，但是，这并不影响它发挥大作用。很多场景对误判有一定的容忍度++。比如我们今天要解决的爬虫判重这个问题，即便一个没有被爬取过的网页，被误判为已经被爬取，对于搜索引擎来说，也并不是什么大事情，是可以容忍的，毕竟网页太多了，搜索引擎也不可能100%都爬取到。

那我们可以用一个10倍大小的位图来存储，也就是100亿个二进制位，换算成字节，那就是大约1.2GB。之前我们用散列表判重，需要至少100GB的空间。相比来讲，布隆过滤器在存储空间的消耗上，降低了非常多。