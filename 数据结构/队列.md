队列（Queue），是一种线性存储结构。它有以下几个特点：
- 队列中数据是按照"先进先出（FIFO, First-In-First-Out）"方式进出队列的。
- 队列只允许在"队首"进行删除操作，而在"队尾"进行插入操作。
- 队列通常包括的两种操作：入队列 和 出队列。

![](https://github.com/binbinbin5/myPics/raw/master/imgs/duilie1.png?raw=true)
![](https://github.com/binbinbin5/myPics/raw/master/imgs/duilie2.png?raw=true)

队列类型:
- 循环队列：
 1. 队空：队头指针在队尾指针的下一位置时，
 2. 队空： Q.front == Q.rear；
 3. 队满：(Q.rear+1)%MAXSIZE=Q.front ，
 4. 队满：当队头和队尾指针在同一位置时；
 5. 队列长度：(Q.rear - Q.front + MAXSIZE) % MAXSIZE

- 非阻塞队列：
1. LinkedList：继承Deque
1. PriorityQueue：优先队列，使用的时最小堆的数据结构，对元素进行了指定排序，不许插入空值；实现了AbstractQueue抽象类和Queue接口
1. ConcurrentLinkedQueue：是基于链接节点的、线程安全的队列；实现了AbstractQueue抽象类和Queue接口


- 阻塞队列:
1. ArrayBlockingQueue： 基于数组的有界队列
1. LinkedBlockingQueue： 基于链表的无界队列
1. ProiporityBlockingQueue：基于优先次序的无界队列
1. DelayQueue：基于时间优先级的队列
1. SynchronousQueue：内部没有容器的队列 较特别  --其独有的线程一一配对通信机制






```
public class MyQueue {
    /**
     * Java : 数组实现“队列”，只能存储int数据。
     */
        private int[] mArray;
        private int end;
        private int head;
        private int size;

        MyQueue(){
            this(10);
        }
        MyQueue(int sz) {
            if (sz <0 ){
                try {
                    throw new Exception("队列不能小于0");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }else{
                mArray = new int[sz];
                size = sz;
                head = end = 0;
            }
        }

        // 将val添加到队列的末尾
        public void add(int val) {
            if (size == end){
                try {
                    throw new Exception("栈满了");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }else{
                mArray[end++] = val;
            }
        }

        // 返回“队列开头元素”
        public int front() {
            return mArray[head];
        }

        // 返回“栈顶元素值”，并删除“栈顶元素”
        public int pop() {
            int re = mArray[head];
            for (int i =0;i<end;i++) {
                mArray[i] = mArray[i + 1];
            }
            end --;
            return re;
        }

        // 返回“栈”的大小
        public int size() {
            return end - head;
        }

        // 返回“栈”是否为空
        public boolean isEmpty() {
            return end-head==0 ?true:false;
        }



}
```





