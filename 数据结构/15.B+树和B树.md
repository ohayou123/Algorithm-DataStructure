# 目录
[toc]

# B树
从算法逻辑上讲，二叉查找树的查找速度和比较次数都是最小的，但是数据库的适用索引需要一个必要的操作：磁盘IO，最坏情况磁盘IO次数等于树的高度，为了减少磁盘IO次数，把树的数据结构变得"矮胖"一点。

B树就诞生了，它是一颗多路平衡查找树，每个节点最多包含K个孩子，K取决于磁盘页的大小。


1. 根结点至少有两个子女。
2. 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m
3. 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
4. 所有的叶子结点都位于同一层。
5. 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。


主要应用：部分飞关系型数据库和文件系统

## 操作
 ![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/adsdq.png)
 
 ### 插入：
 节点3，5已经是两元素节点，无法再增加。父亲节点 2， 6 也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是拆分节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/asdad.png)![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/sdfwefs.png)
 
 ### 删除：
 删除11后，节点12只有一个孩子，不符合B树规范。因此找出12,13,15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子。（这个过程称为左旋）![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/sdgwewerd.png)
 
 ### 查询
 ![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/rgwsdsd.png)
 
 若查询的数值为５： 
1. 第一次磁盘ＩＯ：在内存中定位（与9比较），比9小，左子树； 
2. 第二次磁盘ＩＯ：在内存中定位（与2、6比较），比6小，比2大，中树； 
3. 第三次磁盘ＩＯ：在内存中定位（与3、5比较），找到5，终止。 

整个过程中，我们可以看出：比较的次数并不比二叉查找树少，尤其适当某一节点中的数据很多时，但是磁盘IO的次数却是大大减少。比较是在内存中进行的，相比于磁盘IO的速度，比较的耗时几乎可以忽略。所以当树的高度足够低的话，就可以极大的提高效率。相比之下，节点中的元素多点也没关系，仅仅是多了几次内存交互而已，只要不超过磁盘页的大小即可。

# B+树

### MySQL使用B+树作为索引

1. 索引的话要达到下面几个基础要求：

- 根据某个值查找数据，比如select * from user where id=1234；

- 根据区间值来查找某些数据，比如select * from user where id > 1234 and id < 2345。

- 性能方面的需求，我们主要考察时间和空间两方面，也就是执行效率和存储空间。

>我们使用其他数据结构，比如散列表（单个查询快但是不支持范围查找），平衡二叉树（不支持取件查询），跳表（到时可以满足要求，但是数据库索引所用到的数据结构跟跳表非常相似，叫作B+树）

因为二叉树的查询比较快捷，那么可以采用二叉树，但是二叉树有许多问题需要改进。
首先为了让二叉查找树支持按照区间来查找数据，我们可以对它进行这样的改造：树中的节点并不存储数据本身，而是只是作为索引。除此之外，我们把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。经过改造之后的二叉树，就像图中这样：
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521195613.png)
改造之后，如果我们要求某个区间的数据。我们只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521195738.png)
比起内存读写操作，磁盘IO操作非常耗时，所以我们优化的重点就是尽量减少磁盘IO操作，也就是，尽量降低树的高度。那如何降低树的高度呢？
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521195814.png)



不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是4KB，这个值可以通过getconfig PAGE_SIZE命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次IO操作。所以，我们在选择m大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘IO操作。
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521194610.png)


## 介绍
B+树是对B树的一种变形树，它与B树的差异在于：
1. B+树中的节点不存储数据，只是索引，而B树中的节点存储数据；
1. B树中的叶子节点并不需要链表来串联。

B+树的优势就在于更高的查询性能（单查询+范围查询）。

而且不仅节点之间有重复元素，它的叶子节点直接连接。
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521201415.png)

- 每个父节点的元素都是子节点中最大（最小）值的元素。
- 无论删除插入，根节点都是存有其最大（最小）值。
- 由于父节点的元素子节点都有，所以叶子节点包含所有元素信息。而且一个有序链表的形式存在。
- B+树还有一个特点，就是卫星数据（索引元素所指向的数据记录）只存在叶子节点中，中间节点仅仅是索引。（好处是同样大小的磁盘页可以容纳更多节点元素）
## B+树的特征：

1. 每个节点中子节点的个数不能超过m，也不能小于m/2；
1. 根节点的子节点个数可以不超过m/2，这是一个例外；
1. m叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；
1. 通过链表将叶子节点串联在一起，这样可以方便按区间查找；
1. 一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。

## B+树的优势：
1. 单一节点存储更多的元素，使得查询的IO次数更少。
2. 所有查询都要查找到叶子节点，查询性能稳定。
3. 所有叶子节点形成有序链表，便于范围查询。



### 插入
对于一个B+树来说，m值是根据页的大小事先计算好的，也就是说，每个节点最多只能有m个子节点。在往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过m，这个节点的大小超过了一个页的大小，读取这样一个节点，就会导致多次磁盘IO操作。我们该如何解决这个问题呢？

实际上，处理思路并不复杂。我们只需要将这个节点分裂成两个节点。但是，节点分裂之后，其上层父节点的子节点个数就有可能超过m个。不过这也没关系，我们可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响到根节点。这个分裂过程，你可以结合着下面这个图一块看，会更容易理解（图中的B+树是一个三叉树。我们限定叶子节点中，数据的个数超过2个就分裂节点；非叶子节点中，子节点的个数超过3个就分裂节点）。

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521194657.png)

### 删除
我们在删除某个数据的时候，也要对应的更新索引节点。这个处理思路有点类似跳表中删除数据的处理思路。频繁的数据删除，就会导致某些结点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率。

我们可以设置一个阈值。在B+树中，这个阈值等于m/2。如果某个节点的子节点个数小于m/2，我们就将它跟相邻的兄弟节点合并。不过，合并之后结点的子节点个数有可能会超过m。针对这种情况，我们可以借助插入数据时候的处理方法，再分裂节点。

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521194907.png)

### 查找：
#### 单查询
B+树自顶向下逐层查询节点，最终找到匹配的叶子节点。

比B树中序遍历简单：
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521202618.png)![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521202631.png)![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190521202659.png)

和B树比的优势：
1. 单一节点存储更多的元素，使得查询的IO次数更少。
2. 所有查询都要查找到叶子节点，查询性能稳定。
3. 所有叶子节点形成有序链表，便于范围查询。