[toc]

>注意点：**（图的三者数据结构，图的最短路径（dijkstra），广度深度遍历，多源最短路径(佛洛依德)、最小生成树（普里姆和克鲁斯卡尔））**



## **1、介绍：**

图是由顶点的有穷非空集合和顶点之间边的集合组成， 通常表示为: G（V，E）， 其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。图形结构中，数据元素（顶点）之间具有任意关系，图中任意两个数据元素之间都可能相关。



![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/1tu.png)

## **2、图的概念:**

1. **顶点:**

- 顶点表示图中的一个结点.

比如上图的ABCDEFG等点。



2. **边:**

- 边刚才我们也介绍过了, 表示顶点和顶点之间的连线.

图中: A - B有一条边, B - C有一条边, B - D没有边.



3. **相邻顶点**

- 由一条边连接在一起的顶点称为相邻顶点.

比如A - B是相邻的, B - C是相邻的. B - D是不相邻的



4. **度:**

- 一个顶点的度是相邻顶点的数量.

A的度为3，D的度为1

5. **出度、入度：**

- 有向图中的概念，出度表示以此顶点为起点的边的数目，入度表示以此顶点为终点的边的数目；

B出度为2，入度为0



6. **路径:**

- 路径是顶点v1, v2..., vn的一个连续序列, 比如上图中BAC就是一条路径.
- 简单路径: 简单路径要求不包含重复的顶点. 比如 BAC是一条简单路径.
- 回路: 第一个顶点和最后一个顶点相同的路径称为回路. 比如BDDD



7. **无向图:**

- 上面的图就是一张无向图, 因为所有的边都没有方向.
- 比如 A - C之间有变, 那么说明这条边可以保证 A -> C, 也可以保证 C -> A.



8. **有向图:**

- 有向图表示的图中的边是有方向的.
- 比如 A -> C, 不能保证一定可以 C -> A, 要根据方向来定.



9. **无权图和带权图**

- 无权图:

- - 我们上面的图就是一张无权图(边没有携带权重)
  - 我们上面的图中的边是没有任何意义的, 不能收 A - B的边, 比A - D的边更远或者用的时间更长.

- 带权图:

- - 如下图所示：带权图表示边有一定的权重.
  - 这里的权重可以是任意你希望表示的数据: 比如距离或者花费的时间或者票价

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/2t.png)

10. **网：**

- 带有权重的图



11. **环：**

- 第一个顶点和最后一个顶点相同的路径；

拓扑序列一般用来判断一个图是否是一个有向无环图



12. **连通图：**

- 任意两个顶点都相互连通的图；



13. **极大连通子图：**

- 包含竟可能多的顶点（必须是连通的），即找不到另外一个顶点，使得此顶点能够连接到此极大连通子图的任意一个顶点；



14. **连通分量：**

- 极大连通子图的数量；



15. **强连通图：**

- 此为有向图的概念，表示任意两个顶点a，b，使得a能够连接到b，b也能连接到a 的图；



16. **生成树：**

- n个顶点，n-1条边，并且保证n个顶点相互连通（不存在环）；



17. **最小生成树：**

- 此生成树的边的权重之和是所有生成树中最小的；



18. **AOV网（Activity On Vertex Network ）：**

- 在有向图中若以顶点表示活动，有向边表示活动之间的先后关系



19. **AOE网（Activity On Edge Network）：**

- 在带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间



## **3、图的存储结构**



### **1、邻接矩阵**

**入度和出度：入（队）列，出行（伍）**

图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称邻接矩阵）存储图中的边或弧的信息。

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/3t.png)




```
/**
 * 有向图的邻接矩阵实现
 */
public class Digraph {
    private int vertexsNum;
    private int edgesNum;
    private int[][] arc;

    public Digraph(int[][] data, int vertexsNum) {
        this.vertexsNum = vertexsNum;
        this.edgesNum = data.length;
        arc = new int[vertexsNum][vertexsNum];
        for (int i = 0; i < vertexsNum; i++) {
            for (int j = 0; j < vertexsNum; j++) {
                arc[i][j] = Integer.MAX_VALUE;
            }
        }
        
        for (int i = 0; i < data.length; i++) {
            int tail = data[i][0];
            int head = data[i][1];
            arc[tail][head] = 1;
        }
    }
    
    //用于测试，返回一个顶点的邻接点
    public Iterable<Integer> adj(int vertex) {
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < vertexsNum; i++) {
            if (arc[vertex][i] != Integer.MAX_VALUE)
                set.add(i);
        }
        return set;
    }
    
    public static void main(String[] args) {
        int[][] data = {
                {0,3},
                {1,0},
                {1,2},
                {2,0},
                {2,1},
        };
        Digraph wd = new Digraph(data,4);
        for(int i :wd.adj(1)) {
            System.out.println(i);
        }   
    }
}
```



### **图的存储结构—-邻接矩阵的优缺点**

- 优点： 

直观、容易理解，可以很容易的判断出任意两个顶点是否有边，最大的优点就是很容易计算出各个顶点的度。

- 缺点： 

表示完全图的时候，邻接矩阵是最好的表示方法，但是对于稀疏矩阵，由于它边少，但是顶点多，这样就会造成空间的浪费。



### **2、图的存储结构—邻接表**

邻接表是一种将数组与链表相结合的存储方法。其具体实现为：将图中顶点用一个一维数组存储，每个顶点Vi的所有邻接点用一个单链表来存储。这种方式和树结构中孩子表示法一样。

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/4t.png)




```
/**
 * 有向图的邻接表实现
 *
 */
public class AdjListDigraph {
    
    private class EdgeNode {
        int index;
        EdgeNode next;
        EdgeNode(int index, EdgeNode next){
            this.index = index;
            this.next = next;
        }
    }
    
    private class VertexNode {
        int id;
        EdgeNode headNode;
    }
    
    private VertexNode[] vertexs;
    private int vertexsNum;
    private int edgesNum;
    
    public AdjListDigraph(int[][] data, int vertexsNum) {
        this.vertexsNum = vertexsNum;
        this.edgesNum = data.length;
        vertexs = new VertexNode[vertexsNum];
        for (int i = 0; i < vertexs.length; i++) {
            vertexs[i] = new VertexNode();
            vertexs[i].id = i;        //
        }
        
        for (int i = 0; i < data.length; i++) {
            int index = data[i][1];
            EdgeNode next = vertexs[data[i][0]].headNode;
            EdgeNode eNode = new EdgeNode(index,next);
            vertexs[data[i][0]].headNode = eNode; //头插法
        }
        
    }
    
    //用于测试，返回一个顶点的邻接点
    public Iterable<Integer> adj(int index) {
        Set<Integer> set = new HashSet<>();
        EdgeNode current = vertexs[index].headNode;
        while(current != null) {
            VertexNode node = vertexs[current.index];
            set.add(node.id);
            current = current.next;
        }
        return set;
    }
    
    public static void main(String[] args) {
        int[][] data = {
                {0,3},
                {1,0},
                {1,2},
                {2,0},
                {2,1},
        };
        AdjListDigraph ald = new AdjListDigraph(data,4);
        for(int i :ald.adj(1)) {
            System.out.println(i);
        }   
    }
}
```


### **图的存储结构—-邻接表的优缺点**

- 优点： 

对于，稀疏图，邻接表比邻接矩阵更节约空间。

- 缺点： 

不容易判断两个顶点是有关系（边），顶点的出度容易，但是求入度需要遍历整个邻接表。



### **3、有向图的存储结构—-十字链表**

十字链表（Orthogonal List)是将邻接表和逆邻接表相结合的存储方法，它解决了邻接表（或逆邻接表）的缺陷，即求入度（或出度）时必须遍历整个图

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/5t.png)

图中：

- firstIn表示入边表（即是逆邻接表中的单链表）头指针，firstOut表示出边表（即是邻接表中的单链表）头指针，data表示顶点数据。
- tailVex表示边的起点在顶点数组中的下标，tailNext值出边表指针域，指向起点相同的下一条边。
- headVex表示边的终点在顶点数组中的下标，headNext指入边表指针域，指向终点相同的下一条边。


```
/**
 * 有向图的十字链表实现
 *
 */
public class OrthogonalList {
    
    private class EdgeNode {
        int tailVex;
        int headVex;
        EdgeNode headNext;
        EdgeNode tailNext;
        
        public EdgeNode(int tailVex, int headVex, EdgeNode headNext, EdgeNode tailNext) {
            super();
            this.tailVex = tailVex;
            this.headVex = headVex;
            this.headNext = headNext;
            this.tailNext = tailNext;
        }
        
    }
    
    private class VertexNode {
        int data;
        EdgeNode firstIn;
        EdgeNode firstOut;
    }
    
    private VertexNode[] vertexs;
    private int vertexsNum;
    private int edgesNum;
    
    public OrthogonalList(int[][] data, int vertexsNum) {
        this.vertexsNum = vertexsNum;
        this.edgesNum = data.length;
        vertexs = new VertexNode[vertexsNum];
        for (int i = 0; i < vertexs.length; i++) {
            vertexs[i] = new VertexNode();
            vertexs[i].data = i;        //
        }
        
        //关键
        for (int i = 0; i < data.length; i++) {
            int tail = data[i][0];
            int head = data[i][1];
            EdgeNode out = vertexs[tail].firstOut;
            EdgeNode in = vertexs[head].firstIn;
            EdgeNode eNode = new EdgeNode(tail,head,in,out);
            vertexs[tail].firstOut = eNode;
            vertexs[head].firstIn = eNode;
        }
        
    }
    
    //返回一个顶点的出度
    public int outDegree(int index) {
        int result = 0;
        EdgeNode current = vertexs[index].firstOut;
        while(current != null) {
            current = current.tailNext;
            result++;
        }
        return result;
    }
    
    //返回一个顶点的入度
    public int inDegree(int index) {
        int result = 0;
        EdgeNode current = vertexs[index].firstIn;
        while(current != null) {
            current = current.headNext;
            result++;
        }
        return result;
    }
    
    public static void main(String[] args) {
        int[][] data = {
                {0,3},
                {1,0},
                {1,2},
                {2,0},
                {2,1},
        };
        OrthogonalList orth = new OrthogonalList(data,4);
        System.out.println("顶点1的出度为" + orth.outDegree(1));
        System.out.println("顶点1的入度为" + orth.inDegree(1));
            
    }
}
```
                } } 

十字链表创建图算法的时间复杂度和邻接表相同都为O(N + E)。在有图的应用中推荐使用。





## **4、图的遍历**



### **1、深度优先遍历**

深度优先遍历（Depth First Search，简称DFS），也成为深度优先搜索。



**遍历思想：**基本思想：首先从图中某个顶点v0出发，访问此顶点，然后依次从v相邻的顶点出发深度优先遍历，直至图中所有与v路径相通的顶点都被访问了；若此时尚有顶点未被访问，则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问。

深度优先遍历用递归实现比较简单，**只需用一个递归方法来遍历所有顶点**，在访问某一个顶点时：

将它标为已访问 递归的访问它的所有未被标记过的邻接点 

深度优先遍历的过程：

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/6t.png)




```
public class DFSTraverse {
    
    private boolean[] visited;
    
    //从顶点index开始遍历
    public DFSTraverse(Digraph graph, int index) {
        visited = new boolean[graph.getVertexsNum()];
        dfs(graph,index);
    }

    private void dfs(Digraph graph, int index) {
        visited[index] = true;
        for(int i : graph.adj(index)) {
            if(!visited[i])
                dfs(graph,i);   
        }
    }
}
```






### **2、广度优先遍历**



广度优先遍历（Breadth First Search，简称BFS），又称为广度优先搜索

**遍历思想：**首先，从图的某个顶点v0出发，**访问了v0之后，依次访问与v0相邻的未被访问的顶点，然后分别从这些顶点出发，**广度优先遍历，直至所有的顶点都被访问完。

广度优先遍历的过程：

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/7t.png)




```
public class BFSTraverse {
    
    private boolean[] visited;
    
    public BFSTraverse(AdjListDigraph graph, int index) {
        visited = new boolean[graph.getVertexsNum()];
        bfs(graph,index);
    }

    private void bfs(AdjListDigraph graph, int index) {
        //在JSE中LinkedList实现了Queue接口
        Queue<Integer> queue = new LinkedList<>();
        visited[index] = true;
        queue.add(index);
        while(!queue.isEmpty()) {
            int vertex = queue.poll();
            for(int i : graph.adj(vertex)) {
                if(!visited[i]) {
                    visited[i] = true;
                    queue.offer(i);
                }
            }
        }
    }
}
```




## 5、**最小生成树**

图的生成树是它的一棵含有所有顶点的无环连通子图。一棵加权图的最小生成树（MST）是它的一棵权值（所有边的权值之和）最小的生成树。



计算最小生成树可能遇到的情况：

- 非连通的无向图，不存在最小生成树
- 权重不一定和距离成正比
- 权重可能是0或负数
- 若存在相等的权重，那么最小生成树可能不唯一



图的切分是将图的所有顶点分为两个非空且不重叠的两个集合。横切边是一条连接两个属于不同集合的顶点的边。



>切分定理：在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。

- 切分定理是解决最小生成树问题的所有算法的基础。这些算法都是贪心算法。







### **1、Prim算法**

每次将权值最小的横切边加入生成树中

**此方法的时间复杂度为 O(ElogN)，空间复杂度为 O(N)。**其中，V为顶点个数，E为边数。

**1)、Prim算法的延迟实现(从定点开始，找出已连接的节点中最小权值连接成完成)**

实现过程如下图：

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/8t.png)



从顶点0开始，首先将顶点0加入到树中（标记），顶点0和其它点的横切边（这里即为顶点0的邻接边）加入优先队列，将权值最小的横切边出队，加入生成树中。此时相当于也向树中添加了一个顶点2，接着将集合（顶点1，2组成）和另一个集合（除1,2的顶点组成）间的横切边加入到优先队列中，如此这般，直到队列为空。

注意：若横切边中另一个顶点在树中，则此边失效。




```
public class LazyPrimMST {
    private boolean[] visited; //标记顶点
    private LinkedQueue<Edge> mst; //存储最小生成树的边
    private MinPQ<Edge> pq; //优先队列，权值越最小优先级越高
    
    public LazyPrimMST(WeightedGraph wg) {
        visited = new boolean[wg.getVertexsNum()];
        mst = new LinkedQueue<Edge>();
        pq = new MinPQ<>(wg.getVertexsNum());
        
        visit(wg, 0); //从0点开始
        while(!pq.isEmpty()) {
            Edge e = pq.deQueue();
            int ver1 = e.either();
            int ver2 = e.other(ver1);
            if(visited[ver1] && visited[ver2]) {
                continue; //边失效
            }
            mst.enQueue(e);
            if(!visited[ver1])
                visit(wg, ver1);
            if(!visited[ver2])
                visit(wg, ver2);
        }
    }

    private void visit(WeightedGraph wg, int ver) {
        visited[ver] = true; //标记顶点
        for(Edge e : wg.adj(ver)) {
            if(!visited[e.other(ver)])
                pq.enQueue(e);
        }
    }
    
    public Iterable<Edge> getMST() {
        return mst;
    }
    
    public static void main(String[] args) {
        int[][] data = {
                {0, 2, 2},
                {0, 1, 4},
                {0, 5, 5},
                {1, 2, 3},
                {1, 5, 11},
                {1, 3, 7},
                {2, 3, 8},
                {2, 4, 10},
                {3, 5, 6},
                {3, 4, 1},
                {4, 5, 9}
        };
        WeightedGraph wg = new WeightedGraph(data,6);
        LazyPrimMST lpm = new LazyPrimMST(wg);
        for(Edge e : lpm.getMST()) {
            System.out.println(e);
        }
    }
}
```




### **2、Kruskal算法（从权值排序开始，找出最小权值连接所有点）**

**Kruskal算法的时间复杂度最坏情况下为O(ElogE)。空间复杂度为O(E)。**

对比Prim算法和Kruskal算法，Kruskal算法主要根据边来生成树，边数少时效率比较高，适合稀疏图；而Prim算法对边数多的稠密图效果更好一些。

Kruskal算法的思想是按照边的权重顺序来生成最小生成树，首先将图中所有边加入优先队列，将权重最小的边出队加入最小生成树，保证加入的边不与已经加入的边形成环，直到树中有V-1到边为止。

实现过程如下图：

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/9t.png)




```
/**
 * Kruskal算法的实现
 */
public class KruskalMST {
    private List<Edge> mst; //存储最小生成树的边
    private MinPQ<Edge> pq; //优先队列
    private int[] parent; //用来判断边与边是否形成回路
    
    public KruskalMST(WeightedGraph wg) {
        mst = new ArrayList<Edge>();
        pq = new MinPQ<>(wg.getEdgesNum());
        parent = new int[wg.getVertexsNum()];
        for(Edge e : wg.getEdges()) {
            pq.enQueue(e);
        }
        //最小生成树的边最多为V-1个
        while(!pq.isEmpty() && mst.size() < wg.getVertexsNum() - 1) {
            Edge e = pq.deQueue();
            int v = e.either();
            int n = find(parent, v);
            int m = find(parent, e.other(v));
            if(n != m) { //表示此边没有与生成树形成环路
                parent[n] = m;
                mst.add(e);
            }
        }
    }
    
    //查找连接树的尾部下标
    private int find(int[] data, int v) {
        while(parent[v] > 0) {
            v = parent[v];
        }
        return v;
    }
    
    public Iterable<Edge> getMST() {
        return mst;
    } 
}
```





## **6、最短路径**



### **1、无权图**

采用广义优先搜索算法（BFS）：



![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/10t.png)
第一层，遍历顶点A：

第二层，遍历A的邻接顶点B和C：

第三层，遍历顶点B的邻接顶点D、E，遍历顶点C的邻接顶点F：

第四层，遍历顶点E的邻接顶点G，也就是目标节点：

由此得出，图中顶点A到G的（第一条）最短路径是A-B-E-G：





### **2、有权图**

最短路径指两顶点之间经过的边上权值之和最少的路径，并且称路径上的第一个顶点为源点，最后一个顶点为终点。



​     **Dijkstra算法**：实现过程：**Dijkstra算法的局限性：图中边的权重必须为正，但可以是有环图。时间复杂度为O(ElogV)，空间复杂度O（V）。**



第1步，创建距离表。表中的Key是顶点名称，Value是**从起点A到对应顶点的已知最短距离**。但是，一开始我们并不知道A到其他顶点的最短距离是多少，Value默认是无限大：

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/11t.png)



第2步，遍历起点A，找到起点A的邻接顶点B和C。从A到B的距离是5，从A到C的距离是2。把这一信息刷新到距离表当中：

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/12t.png)

第3步，从距离表中找到从A出发距离最短的点，也就是顶点C。



第4步，遍历顶点C，找到顶点C的邻接顶点D和F（A已经遍历过，不需要考虑）。从C到D的距离是6，所以A到D的距离是2+6=8；从C到F的距离是8，所以从A到F的距离是2+8=10。把这一信息刷新到表中：

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/13t.png)

接下来5、6重复第3步、第4步所做的操作：



第5步，也就是第3步的重复，从距离表中找到从A出发距离最短的点（C已经遍历过，不需要考虑），也就是顶点B。



第6步，也就是第4步的重复，遍历顶点B，找到顶点B的邻接顶点D和E（A已经遍历过，不需要考虑）。从B到D的距离是1，所以A到D的距离是5+1=6，**小于距离表中的8**；从B到E的距离是6，所以从A到E的距离是5+6=11。把这一信息刷新到表中：



![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/17t.png)





（在第6步，A到D的距离从8刷新到6，可以看出距离表所发挥的作用。距离表通过迭代刷新，用新路径长度取代旧路径长度，最终可以得到从起点到其他顶点的最短距离）



第7步，从距离表中找到从A出发距离最短的点（B和C不用考虑），也就是顶点D。



第8步，遍历顶点D，找到顶点D的邻接顶点E和F。从D到E的距离是1，所以A到E的距离是6+1=7，**小于距离表中的11**；从D到F的距离是2，所以从A到F的距离是6+2=8，**小于距离表中的10**。把这一信息刷新到表中：

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/15t.png)

第9步，从距离表中找到从A出发距离最短的点，也就是顶点E。



第10步，遍历顶点E，找到顶点E的邻接顶点G。从E到G的距离是7，所以A到G的距离是7+7=14。把这一信息刷新到表中：

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/19t.png)

第11步，从距离表中找到从A出发距离最短的点，也就是顶点F。



第10步，遍历顶点F，找到顶点F的邻接顶点G。从F到G的距离是3，所以A到G的距离是8+3=11，**小于距离表中的14**。把这一信息刷新到表中：

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20t.png)

就这样，除终点以外的全部顶点都已经遍历完毕，距离表中存储的是从起点A到所有顶点的最短距离。显然，从A到G的最短距离是11。（路径：A-B-D-F-G）






```
/**
 * Dijkstra最短路径算法
 */
public static Map<Integer, Integer> dijkstra(Graph graph, int startIndex) {
    //创建距离表，存储从起点到每一个顶点的临时距离
    Map<Integer, Integer> distanceMap = new HashMap<Integer,Integer>();
    //记录遍历过的顶点
    Set<Integer> accessedSet = new HashSet<Integer> ();
    //图的顶点数量
    int size = graph.vertexes.length;
    //初始化最短路径表，到达每个顶点的路径代价默认为无穷大
    for(int i=1; i<size; i++){
        distanceMap.put(i, Integer.MAX_VALUE);
    }
    //遍历起点，刷新距离表
    accessedSet.add(0);
    List<Edge> edgesFromStart = graph.adj[startIndex];
    for(Edge edge : edgesFromStart)
    {
        distanceMap.put(edge.index, edge.weight);
    }
    //主循环，重复 遍历最短距离顶点和刷新距离表 的操作
    for(int i=1; i<size; i++)
    {
        //寻找最短距离顶点
        int minDistanceFromStart = Integer.MAX_VALUE;
        int minDistanceIndex = -1;
        for(int j=1; j<size; j++)
        {
            if(!accessedSet.contains(j) && distanceMap.get(j) < minDistanceFromStart)
            {
                minDistanceFromStart = distanceMap.get(j);
                minDistanceIndex = j;
            }
        }
        if(minDistanceIndex == -1){
            break;
        }
        //遍历顶点，刷新距离表
        accessedSet.add(minDistanceIndex);
        for(Edge edge : graph.adj[minDistanceIndex])
        {
            if(accessedSet.contains(edge.index)){
                continue;
            }
            int weight = edge.weight;
            int preDistance = distanceMap.get(edge.index);
            if(weight != Integer.MAX_VALUE  && (minDistanceFromStart+ weight < preDistance))
            {
                distanceMap.put(edge.index, minDistanceFromStart + weight);
            }
        }
    }

    return distanceMap;
}

public static void main(String[] args) {
    Graph graph = new Graph(7);
    initGraph(graph);
    Map<Integer, Integer> distanceMap = dijkstra(graph, 0);
    int distance = distanceMap.get(6);
    System.out.println(distance);
}

/**
 * 图的顶点
 */
private static class Vertex {
    String data;
    Vertex(String data) {
        this.data = data;
    }
}

/**
 * 图的边
 */
private static class Edge {
    int index;
    int weight;
    Edge(int index, int weight) {
        this.index = index;
        this.weight = weight;
    }
}

/**
 * 图
 */
private static class Graph {
    private Vertex[] vertexes;
    private LinkedList<Edge> adj[];

    Graph(int size){
        //初始化顶点和邻接矩阵
        vertexes = new Vertex[size];
        adj = new LinkedList[size];
        for(int i=0; i<adj.length; i++){
            adj[i] = new LinkedList<Edge>();
        }
    }
}

private static void initGraph(Graph graph){
    graph.vertexes[0] = new Vertex("A");
    graph.vertexes[1] = new Vertex("B");
    graph.vertexes[2] = new Vertex("C");
    graph.vertexes[3] = new Vertex("D");
    graph.vertexes[4] = new Vertex("E");
    graph.vertexes[5] = new Vertex("F");
    graph.vertexes[6] = new Vertex("G");

    graph.adj[0].add(new Edge(1, 5));
    graph.adj[0].add(new Edge(2, 2));
    graph.adj[1].add(new Edge(0, 5));
    graph.adj[1].add(new Edge(3, 1));
    graph.adj[1].add(new Edge(4, 6));
    graph.adj[2].add(new Edge(0, 2));
    graph.adj[2].add(new Edge(3, 6));
    graph.adj[2].add(new Edge(5, 8));
    graph.adj[3].add(new Edge(1, 1));
    graph.adj[3].add(new Edge(2, 6));
    graph.adj[3].add(new Edge(4, 1));
    graph.adj[3].add(new Edge(5, 2));
    graph.adj[4].add(new Edge(1, 6));
    graph.adj[4].add(new Edge(3, 1));
    graph.adj[4].add(new Edge(6, 7));
    graph.adj[5].add(new Edge(2, 8));
    graph.adj[5].add(new Edge(3, 2));
    graph.adj[5].add(new Edge(6, 3));
    graph.adj[6].add(new Edge(4, 7));
    graph.adj[6].add(new Edge(5, 3));
}
```
